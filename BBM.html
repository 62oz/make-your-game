<!DOCTYPE html>
<html>

<head>
  <style>
    body {
      background-color: black;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #static-board {
      width: 750px;
      height: 750px;
      border: 1px solid black;
      background-image: url("sprites/blue-tile-small.png");
      background-repeat: repeat;
      background-size: 50px 50px;
      position: fixed;
    }

    #score-board {
      font-size: 20px;
      color: white;
      margin-bottom: 10px;
    }

    #countdown-clock {
      font-size: 20px;
      margin-bottom: 10px;
      color: white
    }

    #lives {
      font-size: 20px;
      margin-bottom: 10px;
      color: white;
    }

    #pause-menu {
      display: none;
      width: 200px;
      height: 100px;
      background-color: white;
      border: 1px solid black;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px;
      text-align: center;
    }

    button {
      width: 80px;
      height: 30px;
      margin: 10px;
    }

    .bomb {
      width: 40px;
      height: 40px;
      background-color: red;
      position: absolute;
    }

    #player {
      width: 30px;
      height: 40px;
      position: absolute;
      visibility: visible;
      top: 0;
      left: 0;
    }

    .monster {
      width: 30px;
      height: 40px;
      position: absolute;
      top: 0;
      left: 0;
    }

    .explosion {
      background: yellow;
      height: 140px;
      position: relative;
      top: -50px;
      width: 40px;
      transform: translate(0, calc(-1/3 * 100%));
    }

    .explosion:after {
      background: yellow;
      content: "";
      height: 40px;
      left: -50px;
      position: absolute;
      top: 50px;
      width: 140px;
    }

    .wallBlock {
      width: 50px;
      height: 50px;
      background-image: url("sprites/festival-stand.png");
      position: absolute;
      top: 0;
      left: 0;
    }

    .boxBlock {
      width: 50px;
      height: 50px;
      background-image: url("sprites/Lantern.png");
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>

<body>
  <div id="game-container">
    <div id="static-board">
      <div class="wallBlock"></div>
      <div id="dynamic-board">
        <div id="player"></div>
      </div>
    </div>

    <div id="pause-menu">
      <button id="continue-btn">Continue</button>
      <button id="restart-btn">Restart</button>
    </div>
  </div>
  <div id="score-board"></div>
  <div id="countdown-clock"></div>
  <div id="lives"></div>

  <script>
    // Initialize game variables
    let score = 0;
    let lives = 3;
    let timer = 120;
    let gamePaused = false;
    let startedTimer = true;
    let immune = false;
    // Initialize game elements
    const scoreBoard = document.getElementById("score-board");
    const countdownClock = document.getElementById("countdown-clock");
    const livesDisplay = document.getElementById("lives");
    const pauseMenu = document.getElementById("pause-menu");
    const continueBtn = document.getElementById("continue-btn");
    const restartBtn = document.getElementById("restart-btn");
    const player = document.getElementById("player");
    const explosions = document.getElementsByClassName("explosion");

    //Surround game board with walls
    const staticBoard = document.getElementById("static-board");
    const wallBlock = document.getElementsByClassName("wallBlock");
    for (let i = 0; i < 15; i++) {
      for (let j = 0; j < 15; j++) {
        if (i === 0 || i === 14 || j === 0 || j === 14) {
          const wall = wallBlock[0].cloneNode(true);
          wall.style.top = `${i * 50}px`;
          wall.style.left = `${j * 50}px`;
          staticBoard.appendChild(wall);
        }
      }
    }

    // Add wallBlock every other row and column
    for (let i = 0; i < 15; i++) {
      for (let j = 0; j < 15; j++) {
        if (i % 2 === 0 && j % 2 === 0) {
          const wall = wallBlock[0].cloneNode(true);
          wall.style.top = `${i * 50}px`;
          wall.style.left = `${j * 50}px`;
          staticBoard.appendChild(wall);
        }
      }
    }

    // Add random number between 30 and 80 of boxBlocks to dynamic board, making sure they don't overlap with walls and top and left values must be multiple of 50
    const dynamicBoard = document.getElementById("dynamic-board");
    for (let i = 0; i < Math.floor(Math.random() * 50 + 100); i++) {
      const box = document.createElement("div");
      box.classList.add("boxBlock");
      box.style.top = `${Math.floor(Math.random() * 14 + 1) * 50}px`;
      box.style.left = `${Math.floor(Math.random() * 14 + 1) * 50}px`;
      dynamicBoard.appendChild(box);
    }

    // Remove any boxBlocks between 0 and 200px left and 0 and 100px top
    const boxBlocks = document.getElementsByClassName("boxBlock");
    for (let i = 0; i < boxBlocks.length; i++) {
      if (parseInt(boxBlocks[i].style.left) <= 200 && parseInt(boxBlocks[i].style.top) <= 100) {
        boxBlocks[i].remove();
      }
    }

    // Add monsters to dynamic board
    const spawnMonsters = (N) => {
      for (let i = 0; i < N; i++) {
        const monster = document.createElement("div");
        monster.classList.add("monster");
        monster.style.top = `${Math.floor(Math.random() * 14 + 1) * 50}px`;
        monster.style.left = `${Math.floor(Math.random() * 14 + 1) * 50}px`;
        dynamicBoard.appendChild(monster);
        // If monster is placed on top of wall, remove it and try again
        if (monster.getBoundingClientRect().x === wallBlock[0].getBoundingClientRect().x && monster.getBoundingClientRect().y === wallBlock[0].getBoundingClientRect().y) {
          monster.remove();
          i--;
          continue
        }
        // If monster is placed on top of another monster, remove it and try again
        let monsterDuplicate = false;
        for (let j = 0; j < i; j++) {
          if (monster.getBoundingClientRect().x === document.getElementsByClassName("monster")[j].getBoundingClientRect().x && monster.getBoundingClientRect().y === document.getElementsByClassName("monster")[j].getBoundingClientRect().y) {
            monster.remove();
            i--;
            monsterDuplicate = true;
            break
          }
        }
        if (monsterDuplicate) {
          continue
        }
        // If monster is placed on top of boxBlock, remove it and try again
        for (let j = 0; j < boxBlocks.length; j++) {
          if (monster.getBoundingClientRect().x === boxBlocks[j].getBoundingClientRect().x && monster.getBoundingClientRect().y === boxBlocks[j].getBoundingClientRect().y) {
            monster.remove();
            i--;
            break
          }
        }
      }
    }

    // Define pixel locations of all .wallBlock elements
    let wallBlockPositions = []
    let wallBlocks = document.getElementsByClassName("wallBlock");
    for (let i = 0; i < wallBlocks.length; i++) {
      let wallBlock = wallBlocks[i];
      let wallBlockTop = parseInt(wallBlock.style.top);
      let wallBlockLeft = parseInt(wallBlock.style.left);
      let wallBlockHeight = parseInt(wallBlock.offsetHeight);
      let wallBlockWidth = parseInt(wallBlock.offsetWidth);
      wallBlockPositions.push({
        top: wallBlockTop,
        left: wallBlockLeft,
        bottom: wallBlockTop + wallBlockHeight,
        right: wallBlockLeft + wallBlockWidth
      });
    }
    // Define pixel locations of all .boxBlock elements
    let boxBlockPositions = []
    for (let i = 0; i < boxBlocks.length; i++) {
      let boxBlock = boxBlocks[i];
      let boxBlockTop = parseInt(boxBlock.style.top);
      let boxBlockLeft = parseInt(boxBlock.style.left);
      let boxBlockHeight = parseInt(boxBlock.offsetHeight);
      let boxBlockWidth = parseInt(boxBlock.offsetWidth);
      boxBlockPositions.push({
        top: boxBlockTop,
        left: boxBlockLeft,
        bottom: boxBlockTop + boxBlockHeight,
        right: boxBlockLeft + boxBlockWidth
      });
    }

    // Combined array of all wallBlock and boxBlock positions
    let wallAndBoxBlockPositions = wallBlockPositions.concat(boxBlockPositions);


    spawnMonsters(4);

    // Check if any monster is on top of a wall or boxBlock and if yes remove and respawn
    let monsters = document.getElementsByClassName("monster");
    for (let i = 0; i < monsters.length; i++) {
      let monster = monsters[i];
      let monsterTop = parseInt(monster.style.top);
      let monsterLeft = parseInt(monster.style.left);
      let monsterHeight = parseInt(monster.offsetHeight);
      let monsterWidth = parseInt(monster.offsetWidth);
      let monsterPosition = {
        top: monsterTop,
        left: monsterLeft,
        bottom: monsterTop + monsterHeight,
        right: monsterLeft + monsterWidth
      };
      for (let j = 0; j < wallAndBoxBlockPositions.length; j++) {
        if (monsterPosition.top < wallAndBoxBlockPositions[j].bottom &&
          monsterPosition.bottom > wallAndBoxBlockPositions[j].top &&
          monsterPosition.left < wallAndBoxBlockPositions[j].right &&
          monsterPosition.right > wallAndBoxBlockPositions[j].left) {
          monster.remove();
          spawnMonsters(1);
          monsters = document.getElementsByClassName("monster");
          i = 0
        }
      }
    }


    // Check if there are monsters 0 and 200px left and 0 and 200px top
    for (let i = 0; i < monsters.length; i++) {
      if (parseInt(monsters[i].style.left) <= 200 && parseInt(monsters[i].style.top) <= 200) {
        monsters[i].remove();
        // Spawn new monster
        spawnMonsters(1);
      }
    }

    // Replace all initial monstermonster positions by 10px right and 5px down
    for (let i = 0; i < monsters.length; i++) {
      monsters[i].style.left = `${parseInt(monsters[i].style.left) + 10}px`;
      monsters[i].style.top = `${parseInt(monsters[i].style.top) + 5}px`;
    }

    // Give every monster movementpoint attribute initialized to 0  
    for (let i = 0; i < monsters.length; i++) {
      monsters[i].setAttribute("movementpoint", 50);
    }

    // Give every monster direction attribute
    for (let i = 0; i < monsters.length; i++) {
      monsters[i].setAttribute("direction", "none");
    }

    // Get box and wall blocks positions
    const boxBlocksPositions = [];
    for (let i = 0; i < boxBlocks.length; i++) {
      boxBlocksPositions.push([parseInt(boxBlocks[i].style.left), parseInt(boxBlocks[i].style.top)]);
    }




    // Initialize player movement variables
    let moveLeft = false;
    let moveRight = false;
    let moveUp = false;
    let moveDown = false;
    let moving = false;
    //Initialize player direction variables
    let lookingLeft = false;
    let lookingRight = false;
    let lookingUp = false;
    let lookingDown = true;

    // Handle player movement
    document.addEventListener("keydown", (event) => {
      if (event.key === "ArrowLeft") {
        moving = true;
        moveLeft = true
        lookingLeft = true
        lookingRight = false
        lookingUp = false
        lookingDown = false
      }

      if (event.key === "ArrowRight") {
        moving = true
        moveRight = true
        lookingRight = true
        lookingLeft = false
        lookingUp = false
        lookingDown = false
      }

      if (event.key === "ArrowUp") {
        moving = true
        moveUp = true
        lookingUp = true
        lookingDown = false
        lookingLeft = false
        lookingRight = false
      }

      if (event.key === "ArrowDown") {
        moving = true
        moveDown = true
        lookingDown = true
        lookingUp = false
        lookingLeft = false
        lookingRight = false
      }
    });

    document.addEventListener("keyup", (event) => {
      if (event.key === "ArrowLeft") {
        moveLeft = false;
        moving = false
      }
      if (event.key === "ArrowRight") {
        moveRight = false;
        moving = false
      }
      if (event.key === "ArrowUp") {
        moveUp = false;
        moving = false
      }
      if (event.key === "ArrowDown") {
        moveDown = false;
        moving = false
      }
    });

    let timeAtPause = 0

    // Handle pause/continue game
    document.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        gamePaused = !gamePaused;
        startedTimer = false
        if (gamePaused) {
          timeAtPause = timer;
          pauseMenu.style.display = "block";
          // Handle continue button
          continueBtn.addEventListener("click", () => {
            timer = timeAtPause
            updateMetrics();
            gamePaused = false;
            pauseMenu.style.display = "none";
            gameLoop();
          });
        } else {
          if (timeAtPause) {
            timer = timeAtPause
            updateMetrics();
          }

          pauseMenu.style.display = "none";
          gameLoop();
        }
      }
    });



    // Handle restart game
    restartBtn.addEventListener("click", () => {
      location.reload();
    });


    // Update score, lives and timer
    const updateMetrics = () => {
      scoreBoard.innerHTML = `Score: ${score}`;
      livesDisplay.innerHTML = `Lives: ${lives}`;
      countdownClock.innerHTML = `Timer: ${timer}`;
    };



    // Handle putting bomb in front of player and adding it to bombs array
    const putBomb = () => {
      // Create a new bomb element
      const bomb = document.createElement("div");
      bomb.classList.add("bomb");

      switch (true) {
        case lookingLeft:
          bomb.style.left = Math.floor(parseInt(player.style.left) / 50) * 50 - 45 + "px";
          bomb.style.top = Math.floor(parseInt(player.style.top) / 50) * 50 + 5 + "px";
          break;
        case lookingRight:
          console.log(player.style.left)
          bomb.style.left = Math.ceil((parseInt(player.style.left) - 30) / 50) * 50 + 55 + "px";
          bomb.style.top = Math.floor(parseInt(player.style.top) / 50) * 50 + 5 + "px";
          break;
        case lookingUp:
          bomb.style.left = Math.floor(parseInt(player.style.left) / 50) * 50 + 5 + "px";
          bomb.style.top = Math.floor(parseInt(player.style.top) / 50) * 50 - 45 + "px";
          break;
        case lookingDown:
          bomb.style.left = Math.floor(parseInt(player.style.left) / 50) * 50 + 5 + "px";
          bomb.style.top = Math.ceil((parseInt(player.style.top) - 20) / 50) * 50 + 55 + "px";
          break;
      }

      //Add timer to bomb after which add explosion and delete bomb
      let bombTimeout = setTimeout(() => {
        // Create a new explosion element
        const explosion = document.createElement("div");
        explosion.classList.add("explosion");
        explosion.style.left = bomb.style.left;
        explosion.style.top = bomb.style.top;

        // Delete bomb
        bomb.remove();

        // Add explosion to game board
        document.getElementById("dynamic-board").appendChild(explosion);
        //Explosion disappears after 1 second
        setTimeout(() => {
          explosion.remove();
        }, 1000);

      }, 3000);

      // Get bombs positions
      const bombBlockPositions = [];
      let bombs = document.getElementsByClassName("bomb");
      for (let i = 0; i < bombs.length; i++) {
        bombBlockPositions.push([parseInt(bombs[i].style.left), parseInt(bombs[i].style.top)]);
      }

      // Check if bomb is placed on a bomb
      for (let i = 0; i < bombBlockPositions.length; i++) {
        let bombBlock = bombBlockPositions[i];
        if (parseInt(bomb.style.left) === bombBlock[0] && parseInt(bomb.style.top) === bombBlock[1]) {
          bomb.remove();
          clearInterval(bombTimeout);
          return;
        }
      }


      //Add bomb to game board
      document.getElementById("dynamic-board").appendChild(bomb);

      bombTop = parseInt(bomb.style.top);
      bombLeft = parseInt(bomb.style.left);
      bombBottom = bombTop + parseInt(bomb.offsetHeight);
      bombRight = bombLeft + parseInt(bomb.offsetWidth);

      // Check if bomb is placed on a wall
      for (let i = 0; i < wallBlockPositions.length; i++) {
        let wallBlock = wallBlockPositions[i];
        if (bombTop < wallBlock.bottom && bombBottom > wallBlock.top && bombLeft < wallBlock.right && bombRight > wallBlock.left) {
          bomb.remove();
          clearInterval(bombTimeout);
          return;
        }
      }
      // Check if bomb is placed on a box
      for (let i = 0; i < boxBlockPositions.length; i++) {
        let boxBlock = boxBlockPositions[i];
        if (bombTop < boxBlock.bottom && bombBottom > boxBlock.top && bombLeft < boxBlock.right && bombRight > boxBlock.left) {
          bomb.remove();
          clearInterval(bombTimeout);
          return;
        }
      }
    };

    // Handle putting bomb when pressing spacebar
    document.addEventListener("keydown", (event) => {
      if (event.key === " ") {
        putBomb();
      }
    });

    reduceTimer = () => {
      while (startedTimer) {
        setInterval(() => {
          timer -= 1;
        }, 1000);
        startedTimer = false;
      }
    };

    const monsterLookingRight = new Image();
    monsterLookingRight.src = "sprites/goldfish-right.png";
    const monsterLookingLeft = new Image();
    monsterLookingLeft.src = "sprites/goldfish-left.png";


    //Give each monster animationIndex property
    for (let i = 0; i < monsters.length; i++) {
      monsters[i].animationIndex = 0;
      monsters[i].style.backgroundImage = `url(${monsterLookingRight.src})`;
    }

    let monsterSlowFrameRate = 20;

    // Handle monster movement
    const moveMonsters = () => {

      // Define pixel locations of all .bomb elements + margin
      let bombPositions = []
      let bombs = document.getElementsByClassName("bomb");
      for (let i = 0; i < bombs.length; i++) {
        let bomb = bombs[i];
        let bombTop = parseInt(bomb.style.top);
        let bombLeft = parseInt(bomb.style.left);
        let bombHeight = parseInt(bomb.offsetHeight);
        let bombWidth = parseInt(bomb.offsetWidth);
        bombPositions.push({
          top: bombTop + 10,
          left: bombLeft + 10,
          bottom: bombTop + bombHeight + 10,
          right: bombLeft + bombWidth + 10
        });
      }

      // Define pixel locations of all .monster elements + margin
      let monsterPositions = []
      for (let i = 0; i < monsters.length; i++) {
        let monster = monsters[i];
        let monsterTop = parseInt(monster.style.top);
        let monsterLeft = parseInt(monster.style.left);
        let monsterHeight = parseInt(monster.offsetHeight);
        let monsterWidth = parseInt(monster.offsetWidth);
        monsterPositions.push({
          top: monsterTop + 5,
          left: monsterLeft + 10,
          bottom: monsterTop + monsterHeight + 5,
          right: monsterLeft + monsterWidth + 10
        });
      }


      // Combined wall and box and bomb positions
      let combinedPositions = [...wallBlockPositions, ...boxBlockPositions, ...bombPositions, ...monsterPositions];

      // Check if monster is blocked by wall or box or bomb or another monster
      for (let i = 0; i < monsters.length; i++) {
        let monster = monsters[i];
        let monsterTop = parseInt(monster.style.top);
        let monsterLeft = parseInt(monster.style.left);
        let monsterRight = monsterLeft + parseInt(monster.offsetWidth);
        let monsterBottom = monsterTop + parseInt(monster.offsetHeight);

        let monsterDirection = monster.direction;
        let monsterMovementPoints = monster.movementPoints;

        let monsterBlockedTop = false
        let monsterBlockedRight = false
        let monsterBlockedBottom = false
        let monsterBlockedLeft = false


        // Check if monster is blocked by wall or box or bomb
        for (let i = 0; i < combinedPositions.length; i++) {
          let wallAndBoxBlock = combinedPositions[i];
          //Check if monster is blocked by wall or box on top with 5px margin
          if (monsterTop - 5 <= wallAndBoxBlock.bottom && monsterBottom > wallAndBoxBlock.top && monsterLeft > wallAndBoxBlock.left && monsterRight < wallAndBoxBlock.right) {
            monsterBlockedTop = true;
          }
          //Check if monster is blocked by wall or box on right with 10px margin
          if (monsterRight + 10 >= wallAndBoxBlock.left && monsterLeft < wallAndBoxBlock.right && monsterTop > wallAndBoxBlock.top && monsterBottom < wallAndBoxBlock.bottom) {
            monsterBlockedRight = true;
          }
          //Check if monster is blocked by wall or box on bottom with 5px margin
          if (monsterBottom + 5 >= wallAndBoxBlock.top && monsterTop < wallAndBoxBlock.bottom && monsterLeft > wallAndBoxBlock.left && monsterRight < wallAndBoxBlock.right) {
            monsterBlockedBottom = true;
          }
          //Check if monster is blocked by wall or box on left with 10px margin
          if (monsterLeft - 10 <= wallAndBoxBlock.right && monsterRight > wallAndBoxBlock.left && monsterTop > wallAndBoxBlock.top && monsterBottom < wallAndBoxBlock.bottom) {
            monsterBlockedLeft = true;
          }
        }

        if (playerSlowedBy >= monsterSlowFrameRate) {
          if (monsterDirection === "left") {
            monster.style.backgroundImage = `url(${monsterLookingLeft.src})`;
          } else if (monsterDirection === "right") {
            monster.style.backgroundImage = `url(${monsterLookingRight.src})`;
          }
          drawSprite(monster, monster.animationIndex, 0, 30, 0);
          playerSlowedBy = 0;
          monster.animationIndex += 1
          if (monster.animationIndex > 1) {
            monster.animationIndex = 0;
          }
        } else {
          playerSlowedBy += 1;
        }


        // if movement points < 50, move monster in monster direction and add one to movement points
        if (monsterMovementPoints < 50) {
          switch (true) {
            case monsterDirection === "left":
              // Move if not blocked
              if (!monsterBlockedLeft) {
                monster.style.left = monsterLeft - 1 + "px";
                monster.movementPoints += 1;
              }
              break;
            case monsterDirection === "right":
              // Move if not blocked
              if (!monsterBlockedRight) {
                monster.style.left = monsterLeft + 1 + "px";
                monster.movementPoints += 1;
              }
              break;
            case monsterDirection === "up":
              // Move if not blocked
              if (!monsterBlockedTop) {
                monster.style.top = monsterTop - 1 + "px";
                monster.movementPoints += 1;
              }
              break;
            case monsterDirection === "down":
              // Move if not blocked
              if (!monsterBlockedBottom) {
                monster.style.top = monsterTop + 1 + "px";
                monster.movementPoints += 1;
              }
              break;
          }
        } else {
          // Assign to monster direction that is not blocked
          let monsterDirectionArray = ["left", "right", "up", "down"];
          let monsterDirectionArrayBlocked = [monsterBlockedLeft, monsterBlockedRight, monsterBlockedTop, monsterBlockedBottom];
          let monsterDirectionArrayNotBlocked = [];
          for (let i = 0; i < monsterDirectionArray.length; i++) {
            if (monsterDirectionArrayBlocked[i] === false) {
              monsterDirectionArrayNotBlocked.push(monsterDirectionArray[i]);
            }
          }
          let monsterDirectionArrayNotBlockedRandom = monsterDirectionArrayNotBlocked[Math.floor(Math.random() * monsterDirectionArrayNotBlocked.length)];
          monster.direction = monsterDirectionArrayNotBlockedRandom;
          if (monster.direction !== "none" && monster.direction !== undefined) {
            monster.movementPoints = 0;
          }
        }
      }
    }

    ////ANIMATION STUFF

    const playerRollUpImg = new Image();
    playerRollUpImg.src = "sprites/daruma-doll-roll-down.png";
    const playerRollDownImg = new Image();
    playerRollDownImg.src = "sprites/daruma-doll-roll-up.png";
    const playerRollRightImg = new Image();
    playerRollRightImg.src = "sprites/daruma-doll-roll-left.png";
    const playerRollLeftImg = new Image();
    playerRollLeftImg.src = "sprites/daruma-doll.png";
    const playerUp = new Image();
    playerUp.src = "sprites/daruma-up.png"
    const playerDown = new Image()
    playerDown.src = "sprites/daruma-down.png"
    const playerLookingRight = new Image()
    playerLookingRight.src = "sprites/daruma-right.png"
    const playerLookingLeft = new Image()
    playerLookingLeft.src = "sprites/daruma-left.png"
    const playerTransparent = new Image()
    playerTransparent.src = "sprites/transparent.png"

    let playerYIndex = 0;
    let playerSlowedBy = 0;
    let playerSlowFrameRate = 10;

    player.style.backgroundImage = `url(${playerDown.src})`;

    const drawSprite = (div, frameX, frameY, width, height) => {
      const y = frameY * height;
      const x = frameX * width;
      div.style.backgroundPosition = `${x}px ${y}px`;
    }





    ////////////




    // Game loop using requestAnimationFrame
    const gameLoop = () => {
      if (!gamePaused) {
        //call reduceTimerdrawSpriteRollDown
        reduceTimer();
        moveMonsters();
        touchExplosion();
        touchMonster();

        // Animation stuff
        if (moving) {
          if (moveDown) {
            player.style.backgroundImage = `url(${playerRollDownImg.src})`;
          } else if (moveUp) {
            player.style.backgroundImage = `url(${playerRollUpImg.src})`;
          } else if (moveLeft) {
            player.style.backgroundImage = `url(${playerRollLeftImg.src})`;
          } else if (moveRight) {
            player.style.backgroundImage = `url(${playerRollRightImg.src})`;
          }
          if (playerSlowedBy >= playerSlowFrameRate) {

            drawSprite(player, 0, playerYIndex, 0, 40);
            playerSlowedBy = 0;
            playerYIndex += 1
            if (playerYIndex > 7) {
              playerYIndex = 0;
            }
          } else {
            playerSlowedBy += 1;
          }
        } else {
          if (lookingDown) {
            player.style.backgroundImage = `url(${playerDown.src})`;
          } else if (lookingUp) {
            player.style.backgroundImage = `url(${playerUp.src})`;
          } else if (lookingLeft) {
            player.style.backgroundImage = `url(${playerLookingLeft.src})`;
          } else if (lookingRight) {
            player.style.backgroundImage = `url(${playerLookingRight.src})`;
          }
        }


        // Update player position
        let playerTop = parseInt(player.style.top);
        let playerLeft = parseInt(player.style.left);
        let playerRight = playerLeft + parseInt(player.offsetWidth);
        let playerBottom = playerTop + parseInt(player.offsetHeight);

        // Get positions of bombs
        let bombPositions = [];
        let bombs = document.getElementsByClassName("bomb");
        for (let i = 0; i < bombs.length; i++) {
          let bomb = bombs[i];
          let bombTop = parseInt(bomb.style.top);
          let bombLeft = parseInt(bomb.style.left);
          let bombHeight = parseInt(bomb.offsetHeight);
          let bombWidth = parseInt(bomb.offsetWidth);
          bombPositions.push({
            top: bombTop + 5,
            left: bombLeft + 10,
            bottom: bombTop + bombHeight + 5,
            right: bombLeft + bombWidth + 10
          });
        }

        if (moveLeft) {
          // Find next intersection with wallBlock
          let intersects = false;
          for (let i = 0; i < wallBlockPositions.length; i++) {
            let wallBlock = wallBlockPositions[i];
            if (
              playerLeft - 3 < wallBlock.right &&
              playerRight > wallBlock.left &&
              playerTop < wallBlock.bottom &&
              playerBottom > wallBlock.top
            ) {
              intersects = true;
              break;
            }
          }
          // Find next intersection with boxBlock
          for (let i = 0; i < boxBlockPositions.length; i++) {
            let boxBlock = boxBlockPositions[i];
            if (
              playerLeft - 3 < boxBlock.right &&
              playerRight > boxBlock.left &&
              playerTop < boxBlock.bottom &&
              playerBottom > boxBlock.top
            ) {
              intersects = true;
              break;
            }
          }

          // Find next intersection with bomb
          for (let i = 0; i < bombPositions.length; i++) {
            let bomb = bombPositions[i];
            if (
              playerLeft - 3 < bomb.right &&
              playerRight > bomb.left &&
              playerTop < bomb.bottom &&
              playerBottom > bomb.top
            ) {
              intersects = true;
              break;
            }
          }

          // If new player position is not wallBlockPosition, update player position
          if (!intersects) {
            player.style.left = parseInt(player.style.left) - 3 + "px";
          }
        }
        if (moveRight) {
          // Find next intersection with wallBlock
          let intersects = false;
          for (let i = 0; i < wallBlockPositions.length; i++) {
            let wallBlock = wallBlockPositions[i];
            if (
              playerLeft < wallBlock.right &&
              playerRight + 3 > wallBlock.left &&
              playerTop < wallBlock.bottom &&
              playerBottom > wallBlock.top
            ) {
              intersects = true;
              break;
            }
          }
          // Find next intersection with boxBlock
          for (let i = 0; i < boxBlockPositions.length; i++) {
            let boxBlock = boxBlockPositions[i];
            if (
              playerLeft < boxBlock.right &&
              playerRight + 3 > boxBlock.left &&
              playerTop < boxBlock.bottom &&
              playerBottom > boxBlock.top
            ) {
              intersects = true;
              break;
            }
          }

          // Find next intersection with bomb
          for (let i = 0; i < bombPositions.length; i++) {
            let bomb = bombPositions[i];
            if (
              playerLeft < bomb.right - 10 &&
              playerRight + 20 >= bomb.left &&
              playerTop < bomb.bottom &&
              playerBottom > bomb.top
            ) {
              intersects = true;
              break;
            }
          }

          // If new player position is not wallBlockPosition, update player position
          if (!intersects) {
            player.style.left = parseInt(player.style.left) + 3 + "px";
          }
        }
        if (moveUp) {
          // Find next intersection with wallBlock
          let intersects = false;
          for (let i = 0; i < wallBlockPositions.length; i++) {
            let wallBlock = wallBlockPositions[i];
            if (
              playerLeft < wallBlock.right &&
              playerRight > wallBlock.left &&
              playerTop - 4 < wallBlock.bottom &&
              playerBottom > wallBlock.top
            ) {
              intersects = true;
              break;
            }
          }
          // Find next intersection with boxBlock
          for (let i = 0; i < boxBlockPositions.length; i++) {
            let boxBlock = boxBlockPositions[i];
            if (
              playerLeft < boxBlock.right &&
              playerRight > boxBlock.left &&
              playerTop - 4 < boxBlock.bottom &&
              playerBottom > boxBlock.top
            ) {
              intersects = true;
              break;
            }
          }

          // Find next intersection with bomb
          for (let i = 0; i < bombPositions.length; i++) {
            let bomb = bombPositions[i];
            if (
              playerLeft < bomb.right &&
              playerRight > bomb.left &&
              playerTop - 4 < bomb.bottom &&
              playerBottom > bomb.top + 10
            ) {
              intersects = true;
              break;
            }
          }

          // If new player position is not wallBlockPosition, update player position
          if (!intersects) {
            player.style.top = parseInt(player.style.top) - 3 + "px";
          }
        }

        if (moveDown) {
          // Find next intersection with wallBlock
          let intersects = false;
          for (let i = 0; i < wallBlockPositions.length; i++) {
            let wallBlock = wallBlockPositions[i];
            if (
              playerLeft < wallBlock.right &&
              playerRight > wallBlock.left &&
              playerTop < wallBlock.bottom &&
              playerBottom + 4 > wallBlock.top
            ) {
              intersects = true;
              break;
            }
          }
          // Find next intersection with boxBlock
          for (let i = 0; i < boxBlockPositions.length; i++) {
            let boxBlock = boxBlockPositions[i];
            if (
              playerLeft < boxBlock.right &&
              playerRight > boxBlock.left &&
              playerTop < boxBlock.bottom &&
              playerBottom + 4 > boxBlock.top
            ) {
              intersects = true;
              break;
            }
          }

          // Find next intersection with bomb
          for (let i = 0; i < bombPositions.length; i++) {
            let bomb = bombPositions[i];
            if (
              playerLeft < bomb.right &&
              playerRight > bomb.left &&
              playerTop < bomb.bottom - 10 &&
              playerBottom + 10 > bomb.top
            ) {
              intersects = true;
              break;
            }
          }

          // If new player position is not wallBlockPosition, update player position
          if (!intersects) {
            player.style.top = parseInt(player.style.top) + 3 + "px";
          }
        }

      }
    };

    async function touchMonster() {
      let playerTop = parseInt(player.style.top);
      let playerLeft = parseInt(player.style.left);
      let playerRight = playerLeft + parseInt(player.offsetWidth);
      let playerBottom = playerTop + parseInt(player.offsetHeight);

      for (let i = 0; i < monsters.length; i++) {
        let monsterX = parseInt(monsters[i].style.left);
        let monsterY = parseInt(monsters[i].style.top);
        // Get monster area 30*40
        let minX = monsterX;
        let maxX = monsterX + 30;
        let minY = monsterY;
        let maxY = monsterY + 40;

        if (
          playerLeft < maxX &&
          playerRight > minX &&
          playerTop < maxY &&
          playerBottom > minY
        ) {
          // Player is touched by monster
          if (!immune) {
            lives -= 1;
            immune = true;
            //Make player blink
            let blinking = setInterval(() => {
              player.style.visibility = (player.style.visibility === 'visible') ? 'hidden' : 'visible';
            }, 100);

            setTimeout(() => {
              //Stop player from blinking
              clearInterval(blinking);
              player.style.visibility = 'visible';
              immune = false;
            }, 2000);
          }
        }
      }
    }

    async function touchExplosion() {
      let playerTop = parseInt(player.style.top);
      let playerLeft = parseInt(player.style.left);
      let playerRight = playerLeft + parseInt(player.offsetWidth);
      let playerBottom = playerTop + parseInt(player.offsetHeight);

      for (let i = 0; i < explosions.length; i++) {
        let explosionX = parseInt(explosions[i].style.left);
        let explosionY = parseInt(explosions[i].style.top);

        //Calculate top, left, right and bottom of first rectangle making the explosion area
        let minX1 = explosionX - 40;
        let maxX1 = explosionX + 80;
        let minY1 = explosionY;
        let maxY1 = explosionY + 40;
        //Calculate top, left, right and bottom of second rectangle making the explosion area
        let minX2 = explosionX;
        let maxX2 = explosionX + 40;
        let minY2 = explosionY - 40;
        let maxY2 = explosionY + 80;

        // Check if player is withing first or second rectangle (with playerTop playerLeft playerRight playerBottom)
        if (
          (playerLeft < maxX1 && playerRight > minX1 && playerTop < maxY1 && playerBottom > minY1) ||
          (playerLeft < maxX2 && playerRight > minX2 && playerTop < maxY2 && playerBottom > minY2)
        ) {
          // If player is within explosion area, reduce lives and update lives
          if (!immune) {
            lives -= 1;
            immune = true;
            //Make player blink
            let blinking = setInterval(() => {
              player.style.visibility = (player.style.visibility === 'visible') ? 'hidden' : 'visible';
            }, 100);

            setTimeout(() => {
              //Stop player from blinking
              clearInterval(blinking);
              player.style.visibility = 'visible';
              immune = false;
            }, 2000);
          }
        }

        // Check if any box is within first or second rectangle (with playerTop playerLeft playerRight playerBottom)
        for (let j = 0; j < boxBlockPositions.length; j++) {
          let boxBlock = boxBlockPositions[j];
          if (
            (boxBlock.left < maxX1 && boxBlock.right > minX1 && boxBlock.top < maxY1 && boxBlock.bottom > minY1) ||
            (boxBlock.left < maxX2 && boxBlock.right > minX2 && boxBlock.top < maxY2 && boxBlock.bottom > minY2)
          ) {
            // If box is within explosion area, remove box that has these coordinates
            for (let k = 0; k < boxBlocks.length; k++) {
              let boxToRemove = boxBlocks[k];
              if (boxToRemove.style.left === `${boxBlock.left}px` && boxToRemove.style.top === `${boxBlock.top}px`) {
                boxToRemove.remove();
                score += 10;
              }
            }
          }
        }

        // Update boxBlockPositions
        boxBlockPositions = [];
        for (let i = 0; i < boxBlocks.length; i++) {
          let boxBlock = boxBlocks[i];
          let boxBlockTop = parseInt(boxBlock.style.top);
          let boxBlockLeft = parseInt(boxBlock.style.left);
          let boxBlockRight = boxBlockLeft + parseInt(boxBlock.offsetWidth);
          let boxBlockBottom = boxBlockTop + parseInt(boxBlock.offsetHeight);
          boxBlockPositions.push({
            top: boxBlockTop,
            left: boxBlockLeft,
            right: boxBlockRight,
            bottom: boxBlockBottom
          });
        }

        // Check if any monster is within first or second rectangle 
        let monsterPositions = []
        for (let j = 0; j < monsters.length; j++) {
          let monster = monsters[j];
          let monsterTop = parseInt(monster.style.top);
          let monsterLeft = parseInt(monster.style.left);
          let monsterRight = monsterLeft + parseInt(monster.offsetWidth);
          let monsterBottom = monsterTop + parseInt(monster.offsetHeight);
          monsterPositions.push({
            top: monsterTop,
            left: monsterLeft,
            right: monsterRight,
            bottom: monsterBottom
          });
        }
        for (let j = 0; j < monsterPositions.length; j++) {
          let monsterBlock = monsterPositions[j];
          if (
            (monsterBlock.left < maxX1 && monsterBlock.right > minX1 && monsterBlock.top < maxY1 && monsterBlock.bottom > minY1) ||
            (monsterBlock.left < maxX2 && monsterBlock.right > minX2 && monsterBlock.top < maxY2 && monsterBlock.bottom > minY2)
          ) {
            // If monster is within explosion area, remove monster that has these coordinates
            for (let k = 0; k < monsters.length; k++) {
              let monsterToRemove = monsters[k];
              if (monsterToRemove.style.left === `${monsterBlock.left}px` && monsterToRemove.style.top === `${monsterBlock.top}px`) {
                monsterToRemove.remove();
                score += 200;
              }
            }
          }
        }

      }


      // Update metrics
      updateMetrics();
      // Check for end game conditions
      if (timer <= 0 || lives <= 0) {
        // End game
        // Show game over screen with score and restard button
        let gameOverScreen = document.createElement('div');
        gameOverScreen.style.display = 'flex';
        gameOverScreen.style.flexDirection = 'column';
        gameOverScreen.style.alignItems = 'center';
        gameOverScreen.style.justifyContent = 'center';
        gameOverScreen.style.position = 'absolute';
        gameOverScreen.style.top = '0';
        gameOverScreen.style.left = '0';
        gameOverScreen.style.width = '100%';
        gameOverScreen.style.height = '100%';
        gameOverScreen.style.background = 'rgba(0, 0, 0, 0.5)';
        gameOverScreen.style.zIndex = '1000';
        let gameOverText = document.createElement('h1');
        gameOverText.innerText = 'Game Over';
        gameOverText.style.color = 'white';
        gameOverText.style.fontSize = '50px';
        gameOverText.style.margin = '0';
        gameOverText.style.padding = '0';
        gameOverScreen.appendChild(gameOverText);
        let gameOverScore = document.createElement('h2');
        gameOverScore.innerText = `Score: ${score}`;
        gameOverScore.style.color = 'white';
        gameOverScore.style.fontSize = '30px';
        gameOverScore.style.margin = '0';
        gameOverScore.style.padding = '0';
        gameOverScreen.appendChild(gameOverScore);
        let restartButton = document.createElement('button');
        restartButton.innerText = 'Play again';
        restartButton.style.background = 'white';
        restartButton.style.color = 'black';
        restartButton.style.fontSize = '20px';
        restartButton.style.padding = '32px 16px';
        restartButton.style.border = 'none';
        restartButton.style.borderRadius = '5px';
        restartButton.style.cursor = 'pointer';
        restartButton.style.marginTop = '20px';
        restartButton.addEventListener('click', () => {
          // Restart game
          location.reload();
        });
        gameOverScreen.appendChild(restartButton);
        document.body.appendChild(gameOverScreen);
      } else {
        requestAnimationFrame(gameLoop);
      }
    }

    // Start game
    gameLoop();
    //start with player and bomb in random positions within the board
    let playerX = 60
    let playerY = 60

    player.style.left = playerX + "px";
    player.style.top = playerY + "px";
  </script>
</body>

</html>